--- File: ALL_DUMP ---

--- File: Communication_features.py ---
import binascii

import dpkt


class Communication_wifi:
    def __init__(self,data):
        self.data = data

    def calculating(self):
        pack = dpkt.ieee80211.IEEE80211(self.data)
        type_info = pack.type
        sub_type_info = pack.subtype
        ds_status = pack.DataFromDS().bssid
        src_mac = pack.mgmt.src
        dst_mac = pack.mgmt.dst
        sequence = pack.Data.frag_seq
        pack_id = pack.version
        fragments = pack.more_frag
        duration = pack.duration

        return type_info, sub_type_info, ds_status, src_mac, dst_mac, sequence, pack_id, fragments, duration



class Communication_ble:
    def __init__(self,pack):
        self.pack = pack

    def ble_features(self):
        pass

class Communication_zigbee:
    def __init__(self,pack):
        self.pack = pack

    def zigbee_features(self):
        dst_add = self.pack.destination_address
        src_add = self.pack.originator_address
        pan_id = self.pack.new_PAN_ID
        packets_len = len(self.pack)

        pass
--- File: Connectivity_features.py ---
from Supporting_functions import ip_to_str


class Connectivity_features_basic:
    def __init__(self,packet):
        self.packet = packet

    def get_source_ip(self):
        return ip_to_str(self.packet.src)

    def get_destination_ip(self):
        try:
            return ip_to_str(self.packet.dst)
        except:
            return None

    def get_source_port(self):
        return self.packet.data.sport

    def get_destination_port(self):
        return self.packet.data.dport

    def get_protocol_type(self):
        return self.packet.p
    
    def get_header_len(self):
        return self.packet.data.__hdr_len__ + len(self.packet.data.opts)

class Connectivity_features_time:
    def __init__(self,packet):
        self.packet = packet
    def time_to_live(self):
        return self.packet.ttl

    def jitter(self):
        pass

    def inter_arrival_time(self):
        pass

    def active_time(self):
        pass

    def idle_time(self):
        pass

class Connectivity_features_flags_bytes:
    def __init__(self,packet):
        self.packet = packet
    def get_flags_count(self):
        pass

    def count(self,src_ip_byte, dst_ip_byte):
        if self.packet.src not in src_ip_byte.keys():
            src_ip_byte[self.packet.src] = 1
        else:
            src_ip_byte[self.packet.src] = src_ip_byte[self.packet.src] + 1

        if self.packet.dst not in dst_ip_byte.keys():
            dst_ip_byte[self.packet.dst] = 1
        else:
            dst_ip_byte[self.packet.dst] = dst_ip_byte[self.packet.dst] + 1


        return src_ip_byte[self.packet.src], dst_ip_byte[self.packet.dst]

--- File: Dynamic_features.py ---
import numpy as np
import itertools
from scipy import stats

class Dynamic_features:
    def dynamic_calculation(self,ethsize):
        sum_packets = sum(ethsize)
        min_packets = min(ethsize)
        max_packets = max(ethsize)
        mean_packets = sum_packets / len(ethsize)
        std_packets = np.std(ethsize)

        return sum_packets,min_packets,max_packets,mean_packets,std_packets

    def dynamic_count(self,protcols_count):   #calculates the Number feature
        packets = 0
        for k in protcols_count.keys():
            packets = packets + protcols_count[k]

        return packets

    def dynamic_two_streams(self,incoming, outgoing):

        inco_ave = sum(incoming) / len(incoming)
        outgoing_ave = sum(outgoing) / len(outgoing)
        magnite = (inco_ave + outgoing_ave) ** 0.5

        inco_var = np.var(incoming)
        outgo_var = np.var(outgoing)
        radius = (inco_var + outgo_var) ** 0.5
        if len(incoming) and len(outgoing) >= 2:
            correlation, p_value = stats.pearsonr(incoming, outgoing)
        else:
            correlation = 0

        covaraince = sum((a - inco_ave) * (b - outgoing_ave) for (a, b) in zip(incoming, outgoing)) / len(incoming)
        var_ratio = 0
        if outgo_var != 0:
            var_ratio = inco_var / outgo_var

        weight = len(incoming) * len(outgoing)

        return magnite, radius, correlation, covaraince, var_ratio, weight


--- File: Feature_extraction.py ---
import dpkt
import pandas as pd
import json
from scapy.all import *
from Communication_features import Communication_wifi, Communication_zigbee
from Connectivity_features import Connectivity_features_basic, Connectivity_features_time, \
    Connectivity_features_flags_bytes
from Dynamic_features import Dynamic_features
from Layered_features import L3, L4, L2, L1
from Supporting_functions import get_protocol_name, get_flow_info, get_flag_values, compare_flow_flags, \
    get_src_dst_packets, calculate_incoming_connections, \
    calculate_packets_counts_per_ips_proto, calculate_packets_count_per_ports_proto
    
from tqdm import tqdm
import time
import datetime 

class Feature_extraction():
    columns = ["ts","Header_Length","Protocol Type","Time_To_Live","Rate", 
                   "fin_flag_number","syn_flag_number","rst_flag_number"
                   ,"psh_flag_number","ack_flag_number","ece_flag_number","cwr_flag_number",
                   "ack_count", "syn_count", "fin_count","rst_count",           
                   "HTTP", "HTTPS", "DNS", "Telnet","SMTP", "SSH", "IRC", "TCP", "UDP", "DHCP","ARP", "ICMP", "IGMP", "IPv", "LLC",
        "Tot sum", "Min", "Max", "AVG", "Std","Tot size", "IAT", "Number", "Variance"]
    
    
    def pcap_evaluation(self,pcap_file,csv_file_name):
        global ethsize, src_ports, dst_ports, src_ips, dst_ips, ips , tcpflows, udpflows, src_packet_count, dst_packet_count, src_ip_byte, dst_ip_byte
        global protcols_count, tcp_flow_flgs, incoming_packets_src, incoming_packets_dst, packets_per_protocol, average_per_proto_src
        global average_per_proto_dst, average_per_proto_src_port, average_per_proto_dst_port
        columns = ["ts","Header_Length","Protocol Type","Time_To_Live","Rate", "fin_flag_number","syn_flag_number","rst_flag_number"
                   ,"psh_flag_number","ack_flag_number","ece_flag_number","cwr_flag_number",
                   "ack_count", "syn_count", "fin_count","rst_count",           
                   "HTTP", "HTTPS", "DNS", "Telnet","SMTP", "SSH", "IRC", "TCP", "UDP", "DHCP","ARP", "ICMP", "IGMP", "IPv", "LLC",
        "Tot sum", "Min", "Max", "AVG", "Std","Tot size", "IAT", "Number", "Variance"]
        base_row = {c:[] for c in columns}
        #print(base_row)
        start = time.time()
        ethsize = []
        src_ports = {}  # saving the number of source port used
        dst_ports = {}  # saving the number of destination port used
        tcpflows = {}  # saving the whole tcpflows
        udpflows = {}  # saving the whole udpflows 
        src_packet_count = {}  # saving the number of packets per source IP
        dst_packet_count = {}  # saving the number of packets per destination IP
        dst_port_packet_count = {}  # saving the number of packets per destination port
        src_ip_byte, dst_ip_byte = {}, {}
        tcp_flow_flags = {}  # saving the number of flags for each flow
        packets_per_protocol = {}   # saving the number of packets per protocol
        average_per_proto_src = {}  # saving the number of packets per protocol and src_ip
        average_per_proto_dst = {}  # saving the number of packets per protocol and dst_ip
        average_per_proto_src_port, average_per_proto_dst_port = {}, {}    # saving the number of packets per protocol and src_port and dst_port
        ips = set()  # saving unique IPs
        number_of_packets_per_trabsaction = 0  # saving the number of packets per transaction
        rate, srate, drate = 0, 0, 0
        max_duration, min_duration, sum_duration, average_duration, std_duration = 0, 0, 0, 0, 0   # duration-related features of aggerated records
        total_du = 0 # total duration
        first_pac_time = 0
        last_pac_time = 0
        incoming_pack = []
        outgoing_pack = []
        f = open(pcap_file, 'rb')
        pcap = dpkt.pcap.Reader(f)
        ## Using SCAPY for Zigbee and blutooth ##
        scapy_pak = rdpcap(pcap_file)
        count = 0  # counting the packets
        count_rows = 0
        for ts, buf in (pcap):
            if type(scapy_pak[count]) == scapy.layers.bluetooth:
                pass
            elif type(scapy_pak[count]) == scapy.layers.zigbee.ZigbeeNWKCommandPayload:
                zigbee = Communication_zigbee(scapy_pak[count])
            try:
               eth = dpkt.ethernet.Ethernet(buf)
               count = count + 1
            except:
                count = count + 1
                continue  # If packet format is not readable by dpkt, discard the packet

            #my_src = socket.inet_ntoa(eth.data.src)
			# read the destination IP in dst
            #my_dst = socket.inet_ntoa(eth.data.dst)

            #print ('Timestamp: ', str(datetime.datetime.utcfromtimestamp(ts)))

            

			# Print the source and destination IP
            #print('Source: ' +my_src+ ' Destination: '  +my_dst)
            ethernet_frame_size = len(buf)
            
            #print('buf size : ', len(buf))
            
            #print('ethernet_frame_size : ', ethernet_frame_size)
            #print('size : ', len(eth.data))
            ethernet_frame_type = eth.type
            total_du = total_du + ts
            # initilization #
            src_port, src_ip, dst_port, time_to_live, header_len = 0, 0, 0, 0, 0
            dst_ip, proto_type, protocol_name = 0, 0, ""
            flow_duration, flow_byte = 0, 0
            src_byte_count, dst_byte_count = 0, 0
            src_pkts, dst_pkts = 0, 0
            connection_status = 0
            number = 0
            IAT = 0
            src_to_dst_pkt, dst_to_src_pkt = 0, 0  # count of packets from src to des and vice-versa
            src_to_dst_byte, dst_to_src_byte = 0, 0  # Total bytes of packets from src to dst and vice-versa
            # flags
            flag_valus = []  # numerical values of packet(TCP) flags
            ack_count, syn_count, fin_count, urg_count, rst_count = 0, 0, 0, 0, 0
            # Layered flags
            udp, tcp, http, https, arp, smtp, irc, ssh, dns, ipv, icmp, igmp, mqtt, coap = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
            telnet, dhcp, llc, mac, rarp = 0, 0, 0, 0, 0
            sum_packets, min_packets, max_packets, mean_packets, std_packets = 0, 0, 0, 0, 0
            magnite, radius, correlation, covaraince, var_ratio, weight = 0, 0, 0, 0, 0, 0
            idle_time, active_time = 0, 0
            type_info, sub_type_info, ds_status, src_mac, dst_mac, sequence, pack_id, fragments, wifi_dur = 0, 0, 0, 0, 0, 0, 0, 0, 0
            if eth.type == dpkt.ethernet.ETH_TYPE_IP or eth.type == dpkt.ethernet.ETH_TYPE_ARP:
                ethsize.append(ethernet_frame_size)
                srcs = {}
                dsts = {}

                if last_pac_time == 0: 
                    last_pac_time = ts
                IAT = ts - last_pac_time
                last_pac_time = ts
                if len(ethsize) % 20 == 0:  
                    dy = Dynamic_features()    
                    #sum_packets, min_packets, max_packets, mean_packets, std_packets = dy.dynamic_calculation(ethsize)
                    #print('sum packets : ', sum_packets)
                    #magnite, radius, correlation, covaraince, var_ratio, weight = dy.dynamic_two_streams(incoming_pack,
                                                                                                      #   outgoing_pack) 
                    ethsize = []
                    srcs = {}
                    dsts = {}
                    incoming_pack = []
                    outgoing_pack = []
                    first_pac_time = 0 
                    #last_pac_time = ts
                    #IAT = last_pac_time - first_pac_time
                    #first_pac_time = last_pac_time
                else:
                    dy = Dynamic_features()
                    #sum_packets, min_packets, max_packets, mean_packets, std_packets = dy.dynamic_calculation(ethsize)
                    #print('sum packets : ', sum_packets)
                    #last_pac_time = ts
                    #IAT = last_pac_time - first_pac_time
                    #first_pac_time = last_pac_time
                    #con_basic = Connectivity_features_basic(eth.data)
                    #dst = con_basic.get_destination_ip()
                    #src = con_basic.get_destination_ip()
                    #src= con_basic.get_source_ip()  
                    #print('The destination is : ', dst)
                    #print('The source 1 is : ', src)
                    #print('The source 2 is : ', src2)

               
                   
                    '''if src in dsts:
                        outgoing_pack.append(ethernet_frame_size)
                    else:
                        dsts[src] = 1
                        outgoing_pack.append(ethernet_frame_size)

                    if dst in srcs:
                        incoming_pack.append(ethernet_frame_size)
                    else:
                        srcs[dst] = 1
                        incoming_pack.append(ethernet_frame_size)'''
                    #magnite, radius, correlation, covaraince, var_ratio, weight = dy.dynamic_two_streams(incoming_pack,
                                                                                                         #outgoing_pack)
                    # print("not 20 yet")
                if eth.type == dpkt.ethernet.ETH_TYPE_IP:     # IP packets
                    # print("IP packet")
                
                    
                    ipv = 1
                    ip = eth.data

                    if ip == dpkt.ip6.IP6:  # discard IPv6 packets
                        continue


                    con_basic = Connectivity_features_basic(ip)

                    #Dynamic_packets
                    dy = Dynamic_features()
                    # number = dy.dynamic_count(protcols_count) 


                    # Connectivity_basic_features
                    src_ip = con_basic.get_source_ip()

                    proto_type = con_basic.get_protocol_type()
                    #print("The protocol type is : " , proto_type)
                    dst_ip = con_basic.get_destination_ip()

                    ips.add(dst_ip)
                    ips.add(src_ip)

                    # Connectivity_time_features
                    con_time = Connectivity_features_time(ip)
                    time_to_live= con_time.time_to_live() # time_to_live of packet
                    potential_packet = ip.data

                    # Connectivity_features_flags_bytes
                    # Counts the src ips and dest ips
                    conn_flags_bytes = Connectivity_features_flags_bytes(ip)
                    src_byte_count, dst_byte_count = conn_flags_bytes.count(src_ip_byte, dst_ip_byte) 

                    # L_three_layered_features
                    l_three = L3(potential_packet)
                    udp = l_three.udp()
                    tcp = l_three.tcp()

                    protocol_name = get_protocol_name(proto_type)
                    if protocol_name == "ICMP":
                        icmp = 1
                    elif protocol_name == "IGMP":
                        igmp = 1
                    # L1_features
                    l_one = L1(potential_packet)
                    llc = l_one.LLC()
                    mac = l_one.MAC()


                    # Extra features of Bot-IoT and Ton-IoT

                    # Average rate features
                    calculate_packets_counts_per_ips_proto(average_per_proto_src, protocol_name, src_ip, average_per_proto_dst,
                                              dst_ip)
                    calculate_packets_count_per_ports_proto(average_per_proto_src_port, average_per_proto_dst_port,
                                                            protocol_name, src_port, dst_port)
                    #----end of Average rate features ---#

                    # if packets_per_protocol.get(protocol_name):
                    #     packets_per_protocol[protocol_name] = packets_per_protocol[protocol_name] + 1
                    # else:
                    #     packets_per_protocol[protocol_name] = 1

                    # if protocol_name in protcols_count.keys():
                    #     protcols_count[protocol_name] = protcols_count[protocol_name] + 1
                    # else:
                    #     protcols_count[protocol_name] = 1


                    
                    if src_ip not in src_packet_count.keys():
                        src_packet_count[src_ip] = 1
                    else:
                        src_packet_count[src_ip] = src_packet_count[src_ip] + 1


                    if dst_ip not in dst_packet_count.keys():
                        dst_packet_count[dst_ip] = 1
                    else:
                        dst_packet_count[dst_ip] = dst_packet_count[dst_ip] + 1

                    src_pkts, dst_pkts = src_packet_count[src_ip], dst_packet_count[dst_ip] # counts of source, and dest ips
                    l_four_both = L4(src_port, dst_port)
                    coap = l_four_both.coap()
                    smtp = l_four_both.smtp()
                    # Features related to UDP
                    if type(potential_packet) == dpkt.udp.UDP:
                        src_port = con_basic.get_source_port()
                        dst_port = con_basic.get_destination_port()
                        header_len = 8 #Header length is fixed in UDP 
                        # L4 features
                        l_four = L4(src_port, dst_port)
                        l_two = L2(src_port, dst_port)
                        dhcp = l_two.dhcp()
                        dns = l_four.dns()
                        if dst_port in dst_port_packet_count.keys():
                            dst_packet_count[dst_port] = dst_port_packet_count[dst_port] + 1
                        else:
                            dst_packet_count[dst_port] = 1

                        flow = sorted([(src_ip, src_port), (dst_ip, dst_port)])
                        flow = (flow[0], flow[1])
                        flow_data = {
                            'byte_count': len(eth),
                            'header_len' : header_len,
                            'ts': ts
                        }
                        if udpflows.get(flow):
                            udpflows[flow].append(flow_data)
                        else:
                            udpflows[flow] = [flow_data]
                        packets = udpflows[flow]
                        number_of_packets_per_trabsaction = len(packets)
                        flow_byte, flow_duration, max_duration, min_duration, sum_duration, average_duration, std_duration, idle_time,active_time = get_flow_info(udpflows,flow)
                        src_to_dst_pkt, dst_to_src_pkt, src_to_dst_byte, dst_to_src_byte = get_src_dst_packets(udpflows, flow)
                    # Features related to TCP
                    elif type(potential_packet) == dpkt.tcp.TCP:
                        src_port = con_basic.get_source_port()
                        dst_port = con_basic.get_destination_port()
                        header_len = con_basic.get_header_len()
                        #print('Header Length TCP : ', header_len)
                        if dst_port in dst_port_packet_count.keys():
                            dst_packet_count[dst_port] = dst_port_packet_count[dst_port] + 1
                        else:
                            dst_packet_count[dst_port] = 1

                        flag_valus = get_flag_values(ip.data)
                        # L4 features based on TCP
                        l_four = L4(src_port,dst_port)
                        http = l_four.http()
                        https = l_four.https()
                        ssh = l_four.ssh()
                        irc = l_four.IRC()
                        smtp = l_four.smtp()
                        mqtt = l_four.mqtt()
                        telnet = l_four.telnet()

                        try:
                            http_info = dpkt.http.Response(ip.data)
                            connection_status = http_info.status
                        except:
                            # print("No status")
                            connection_status = 0


                        flow = sorted([(src_ip, src_port), (dst_ip, dst_port)])
                        flow = (flow[0], flow[1])
                        flow_data = {
                            'byte_count': len(eth),
                            'header_len': header_len,
                            'ts': ts
                        }
                        
                        ack_count,syn_count,fin_count,urg_count,rst_count = compare_flow_flags(flag_valus,ack_count,syn_count,fin_count,urg_count,rst_count)
                     
                        
                        if tcpflows.get(flow):
                            tcpflows[flow].append(flow_data)
                            # comparing Flow state based on its flags
                            #ack_count, syn_count, fin_count, urg_count, rst_count = tcp_flow_flags[flow]
                            #ack_count,syn_count,fin_count,urg_count,rst_count = compare_flow_flags(flag_valus,ack_count,syn_count,fin_count,urg_count,rst_count)
                         
                            #tcp_flow_flags[flow] = [ack_count, syn_count, fin_count, urg_count, rst_count]
                        else:
                            tcpflows[flow] = [flow_data]
                            #ack_count,syn_count,fin_count,urg_count,rst_count = compare_flow_flags(flag_valus, ack_count, syn_count, fin_count, urg_count, rst_count)
        
                            #tcp_flow_flags[flow] = [ack_count,syn_count,fin_count,urg_count,rst_count]


                        
                        packets = tcpflows[flow]
                        #Get the number of packets in that specific flow 
                        number_of_packets_per_trabsaction = len(packets)
                        flow_byte, flow_duration,max_duration,min_duration,sum_duration,average_duration,std_duration,idle_time,active_time = get_flow_info(tcpflows,flow)
                        #Calculates the no of packets for each flow vice -versa, and the total no. of bytes 
                        src_to_dst_pkt, dst_to_src_pkt, src_to_dst_byte, dst_to_src_byte = get_src_dst_packets(tcpflows, flow)

                    # calculate_incoming_connections(incoming_packets_src, incoming_packets_dst, src_port, dst_port, src_ip, dst_ip)
                    if flow_duration != 0:
                        rate = number_of_packets_per_trabsaction / flow_duration
                        srate = src_to_dst_pkt / flow_duration
                        drate = dst_to_src_pkt / flow_duration

                    if dst_port_packet_count.get(dst_port):
                        dst_port_packet_count[dst_port] = dst_port_packet_count[dst_port] + 1
                    else:
                        dst_port_packet_count[dst_port] = 1









                elif eth.type == dpkt.ethernet.ETH_TYPE_ARP:   # ARP packets
                    # print("ARP packet")
                    protocol_name = "ARP"
                    arp = 1
                    if packets_per_protocol.get(protocol_name):
                        packets_per_protocol[protocol_name] = packets_per_protocol[protocol_name] + 1
                    else:
                        packets_per_protocol[protocol_name] = 1


                    calculate_packets_counts_per_ips_proto(average_per_proto_src, protocol_name, src_ip, average_per_proto_dst,
                                              dst_ip)

                elif eth.type == dpkt.ieee80211:   # Wifi packets
                    wifi_info = Communication_wifi(eth.data)
                    type_info, sub_type_info, ds_status, src_mac, dst_mac, sequence, pack_id, fragments,wifi_dur = wifi_info.calculating()
                    # print("Wifi related")
                elif eth.type == dpkt.ethernet.ETH_TYPE_REVARP:  # RARP packets
                    rarp = 1   # Reverce of ARP

                # Average rate features
                # for key in average_per_proto_src:
                #     AR_P_Proto_P_SrcIP[key] = average_per_proto_src[key] / total_du

                # for key in average_per_proto_dst:
                #     AR_P_Proto_P_Dst_IP[key] = average_per_proto_dst[key] / total_du

                # for key in average_per_proto_src_port:
                #     ar_p_proto_p_src_sport[key] = average_per_proto_src_port[key] / total_du

                # for key in average_per_proto_dst_port:
                #     ar_p_proto_p_dst_dport[key] = average_per_proto_dst_port[key] / total_du

                # end of average rate features
                if len(flag_valus) == 0:
                    for i in range(0,8):
                        flag_valus.append(0)
                
                new_row = {
                           'ts': ts,
                           "Header_Length": header_len,
                            "Protocol Type": proto_type, 
                           "Time_To_Live": time_to_live,        
                                  
                            "Rate": 0,  
                          
                          "fin_flag_number": flag_valus[0],     
                          "syn_flag_number":flag_valus[1],      
                          "rst_flag_number":flag_valus[2],      
                          "psh_flag_number": flag_valus[3],     
                          "ack_flag_number": flag_valus[4],     
                          "ece_flag_number":flag_valus[6],      
                          "cwr_flag_number":flag_valus[7],      
                        
                           "ack_count":ack_count,               
                           "syn_count":syn_count,               
                           "fin_count": fin_count,                           
                           "rst_count": rst_count,              
                
                           "HTTP": http,                           
                           "HTTPS": https,                         
                           "DNS": dns,                             
                           "Telnet":telnet,                        
                           "SMTP": smtp,                           
                           "SSH": ssh,                             
                           "IRC": irc,                             
                           "TCP": tcp,                             
                           "UDP": udp,                             
                           "DHCP": dhcp,                           
                           "ARP": arp,                             
                           "ICMP": icmp,                           
                           "IGMP": igmp,                           
                           "IPv": ipv,                             
                           "LLC": llc,                             

                           "Tot sum": 0,                           #This value will be reassigned when writing the csv by using the Tot Size attribute 
                           "Min": 0,                               
                           "Max": 0,                               
                           "AVG": 0,                               
                           "Std": 0,                               
                           "Tot size": ethernet_frame_size,         
                           "IAT": IAT, 
                           "Number": 1,                            #Number of packets

                           "Variance":0,                           
                          }
                for c in base_row.keys():
                    base_row[c].append(new_row[c])
                    
                count_rows+=1
                
 
        processed_df = pd.DataFrame(base_row)
        # summary
        last_row = 0
        #if(len(processed_df)%2==0):
         #   n_rows = 10
        #else: 
         #   n_rows = 15
        n_rows = 10
        df_summary_list = []
        while last_row<len(processed_df):
            #Get the first n_processed rows
            sliced_df = processed_df[last_row:last_row+n_rows]
            #Get the mode of the protocol type
            sliced_df_protocol_type_mode = pd.DataFrame(sliced_df['Protocol Type'].mode())
            sum_of_ack_count = (sliced_df["ack_count"].sum())
            sum_of_syn_count = (sliced_df['syn_count'].sum())
            sum_of_fin_count = (sliced_df['fin_count'].sum())
            sum_of_rst_count = (sliced_df['rst_count'].sum())
            total_sum_of_lengths = (sliced_df['Tot size'].sum())
            min_packet_length = (sliced_df['Tot size'].min())
            max_packet_length = (sliced_df['Tot size'].max())
            mean_packet_length = (sliced_df['Tot size'].mean())
            std_packet_length = (sliced_df['Tot size'].std())
            variance_packet_lengths = (sliced_df['Tot size'].var())
            #covariance_packet_lenghts = (sliced_df['Tot size'].cov())
            num_of_packets = (sliced_df['Number'].sum())
            duration_time_interval = (sliced_df['ts'].max() - sliced_df['ts'].min())

            #print(sliced_df_protocol_type_mode)
            #Get the mean of the tables
            sliced_df = pd.DataFrame(sliced_df.mean()).T# mean
            #replace the columns
            sliced_df['Protocol Type'] = sliced_df_protocol_type_mode
            sliced_df['ack_count'] = sum_of_ack_count
            sliced_df['syn_count'] = sum_of_syn_count
            sliced_df['fin_count'] = sum_of_fin_count
            sliced_df['rst_count'] = sum_of_rst_count
            sliced_df['Tot sum'] = total_sum_of_lengths
            sliced_df['Min'] = min_packet_length
            sliced_df['Max'] = max_packet_length
            sliced_df['AVG'] = mean_packet_length
            sliced_df['Std'] = std_packet_length
            sliced_df['Number'] = num_of_packets
            sliced_df['Rate'] = num_of_packets/duration_time_interval
            sliced_df['Variance'] = variance_packet_lengths
            #sliced_df['Covariance'] = covariance_packet_lenghts
        

            df_summary_list.append(sliced_df)
            last_row += n_rows
        processed_df = pd.concat(df_summary_list).reset_index(drop=True)
        processed_df = processed_df.drop(columns = 'ts')
        processed_df.to_csv(csv_file_name+".csv", index=False)
        return True


--- File: Generating_dataset.py ---
from Feature_extraction import Feature_extraction
import time
import warnings
warnings.filterwarnings('ignore')
import os
from tqdm import tqdm
from multiprocessing import Process
import numpy as np
import pandas as pd

if __name__ == '__main__':

    start = time.time()
    print("========== CIC IoT feature extraction ==========")
    
    pcapfiles = [] #Place your pcap files here.
    subfiles_size = 10 # MB
    split_directory = 'split_temp/'
    destination_directory = 'output/'
    converted_csv_files_directory = 'csv_files/'
    n_threads = 8
    
    address = "./"
    
        

    
    for i in range(len(pcapfiles)):
        lstart = time.time()
        pcap_file = pcapfiles[i]
        print(pcap_file)
        print(">>>> 1. splitting the .pcap file.")
        os.system('tcpdump -r '+ pcap_file +' -w ' + split_directory + 'split_temp -C ' + str(subfiles_size))
        subfiles = os.listdir(split_directory)
        print(">>>> 2. Converting (sub) .pcap files to .csv files.")
        processes = []
        errors = 0
        
        subfiles_threadlist = np.array_split(subfiles, (len(subfiles)/n_threads)+1)
        for f_list in tqdm(subfiles_threadlist):
            n_processes = min(len(f_list), n_threads)
            assert n_threads >= n_processes
            assert n_threads >= len(f_list)
            processes = []
            for i in range(n_processes):
                fe = Feature_extraction()
                f = f_list[i]
                subpcap_file = split_directory + f
                p = Process(target=fe.pcap_evaluation, args=(subpcap_file,destination_directory + f.split('.')[0]))
                p.start()
                processes.append(p)
            for p in processes:
                p.join()
        print('The length of subfiles : ', len(subfiles))
        print('The length of destination directory : ', len(os.listdir(destination_directory)))
     #   assert len(subfiles)==len(os.listdir(destination_directory))
        print(">>>> 3. Removing (sub) .pcap files.")
        for sf in subfiles:
            os.remove(split_directory + sf)

        print(">>>> 4. Merging (sub) .csv files (summary).")
        
        csv_subfiles = os.listdir(destination_directory)
        mode = 'w'
        for f in tqdm(csv_subfiles):
            try:
                d = pd.read_csv(destination_directory + f)
                d.to_csv(pcap_file + '.csv', header=mode=='w', index=False, mode=mode)
                mode='a'
            except:
                pass

        print(">>>> 5. Removing (sub) .csv files.")
        for cf in tqdm(csv_subfiles):
            os.remove(destination_directory + cf)
        print(f'done! ({pcap_file})(' + str(round(time.time()-lstart, 2))+ 's),  total_errors= '+str(errors))
        
    end = time.time()
    print(f'Elapsed Time = {(end-start)}s')
    
    
    

--- File: Layered_features.py ---
import dpkt


class L4:
    def __init__(self, src_port, dst_port):
        self.src_port = src_port
        self.dst_port = dst_port

    def mqtt(self):
        # print("mqtt") # USED for TCP
        if self.src_port == 1883 or self.dst_port == 1883:
            return 1
        else:
            return 0

    def coap(self):  # USED for both TCP and UDP
        # print("coap")
        if self.src_port ==5683 or self.dst_port == 5683:
            return 1
        else:
            return 0

    def http(self): # USED for TCP
        # print("http")
        if self.src_port == 80 or self.dst_port == 80:
            return 1
        else:
            return 0

    def https(self):  # USED for TCP
        # print("https")
        if self.src_port == 443 or self.dst_port == 443:
            return 1
        else:
            return 0

    def dns(self): # USED for UDP
        # print("dns")
        if self.dst_port == 53 or self.src_port == 53:
            return 1
        else:
            return 0

    def telnet(self): # USED for TCP
        # print("telnet")
        if self.src_port == 23 or self.dst_port == 23:
            return 1
        else:
            return 0

    def smtp(self): # both of TCP and UDP
        # print("smtp")
        if self.dst_port == 25 or self.src_port == 25:
            return 1
        else:
            return 0

    def ssh(self): # USED for TCP
        # print("ssh")
        if self.dst_port == 22 or self.src_port == 22:
            return 1
        else:
            return 0

    def IRC(self): # USED for TCP
        # print("IRC")
        if self.dst_port == 21 or self.src_port == 21:
            return 1
        else:
            return 0


class L3:
    def __init__(self, packet):
        self.packet = packet

    def tcp(self):
        # print("tcp")
        if type(self.packet) == dpkt.tcp.TCP:
            return 1
        else:
            return 0

    def udp(self):
        # print("udp")
        if type(self.packet) == dpkt.udp.UDP:
            return 1
        else:
            return 0

class L2:
    def __init__(self,src_port, dst_port):
        self.src_port = src_port
        self.dst_port = dst_port

    def dhcp(self):  # USED for UDP
        if self.src_port == 67 and self.dst_port == 68:
            return 1
        
        elif self.src_port == 68 and self.dst_port == 67:
            return 1
        else:
            return 0

class L1:
    def __init__(self, packet):
        self.packet = packet

    def LLC(self):
        if type(self.packet == dpkt.llc):
            return 1
        else:
            return 0
    def MAC(self):
        return dpkt.ethernet.Ethernet.__flags__
--- File: Supporting_functions.py ---
import socket
import struct
from functools import reduce
import numpy as np

def ip_to_str(ip):
    """
     converts and source or destination ip to string values
    """
    ip = socket.inet_ntoa(ip)

    return ip

def get_protocol_name(protocol_val):
    """
    returns the name of Protocol
    """
    if protocol_val == 0:
        return "IP"
    elif protocol_val == 6:
        return "TCP"

    elif protocol_val == 17:
        return "UDP"

    elif protocol_val == 2:
        return "IGMP"

    elif protocol_val == 1:
        return "ICMP"

    else:
        return "Unknown for now"

def get_flow_info(flows, flow):
    """
    generating flow features
    """

    bytes = reduce(lambda x, y: x+y,
                   map(lambda e: e['byte_count'], flows[flow]))
    duration = sorted(map(lambda e: e['ts'], flows[flow]))
    if len(duration)>1:
        idle_time = duration[len(duration)-1] - duration[len(duration) - 2]
    else:
        idle_time = duration[len(duration)-1]

    max_duration = max(duration)
    min_duration = min(duration)
    sum_duration = sum(duration)
    average_duration = sum(duration) / len(duration)
    std_duration = np.std(duration)
    duration = duration[-1] - duration[0]
    active_time = duration

    #print('header length : ' , bytes) 

    return bytes,duration,max_duration,min_duration,sum_duration,average_duration,std_duration,idle_time,active_time

def get_flag_values(tcp):
    """
    getting the numerical values of flags
    """
    fin_flag = (tcp.flags & 0x01) != 0
    syn_flag = (tcp.flags & 0x02) != 0
    rst_flag = (tcp.flags & 0x04) != 0
    psh_flag = (tcp.flags & 0x08) != 0
    ack_flag = (tcp.flags & 0x10) != 0
    urg_flag = (tcp.flags & 0x20) != 0
    ece_flag = (tcp.flags & 0x40) != 0
    cwr_flag = (tcp.flags & 0x80) != 0
    outputs = []
    outputs.append(fin_flag)
    outputs.append(syn_flag)
    outputs.append(rst_flag)
    outputs.append(psh_flag)
    outputs.append(ack_flag)
    outputs.append(urg_flag)
    outputs.append(ece_flag)
    outputs.append(cwr_flag)
    for k in range(0,len(outputs)):
        if outputs[k] == True:
            outputs[k] = 1
        else:
            outputs[k] = 0

    return outputs

def compare_flow_flags(flag_valus,ack_count,syn_count,fin_count,urg_count,rst_count):
    """
    comparing the flags to see how many times are they set
    """
    if flag_valus[4] == 1:
        ack_count = ack_count + 1
    if flag_valus[1] == 1:
        syn_count = syn_count + 1
    if flag_valus[0] == 1:
        fin_count = fin_count + 1
    if flag_valus[5] == 1:
        urg_count = urg_count + 1
    if flag_valus[2] == 1:
        rst_count = rst_count + 1

    return ack_count,syn_count,fin_count,urg_count,rst_count

def get_src_dst_packets(flows,flow):
    """
    calculating the number of packets from source_destination and vice-versa
    :param flows:
    :param flow:
    :return: src_to_dst_pkt,dst_to_src_pkt,src_to_dst_byte, dst_to_src_byte
    """
    src_to_dst_pkt = 0
    dst_to_src_pkt = 0
    src_to_dst_byte = 0
    dst_to_src_byte = 0
    if flows.get(flow):
        packets = flows[flow]
        src_to_dst_pkt = len(packets)
        for i in range(0,len(packets)):
            src_to_dst_byte = src_to_dst_byte + packets[i]['byte_count']


    newflow = (flow[1], flow[0])
    if flows.get(newflow):
        packets = flows[newflow]
        dst_to_src_pkt = len(packets)
        for i in range(0, len(packets)):
            dst_to_src_byte = dst_to_src_byte + packets[i]['byte_count']


    return src_to_dst_pkt, dst_to_src_pkt, src_to_dst_byte, dst_to_src_byte

def calculate_incoming_connections(src_pkt, dst_pkt, src_port,dst_port,src_ip,dst_ip):
    """
    caculate the number of incoming connections per src_ip and dst_ip
    :param src_pkt:
    :param dst_pkt:
    :param src_port:
    :param dst_port:
    :param src_ip:
    :param dst_ip:
    :return:
    """

    if (src_port < 1024 and src_port > 0) or (dst_port < 1024 and dst_port > 0):
        if src_pkt.get(src_ip):
            src_pkt[src_ip] = src_pkt[src_ip] + 1
        else:
            src_pkt[src_ip] = 1

        if dst_pkt.get(dst_ip):
            dst_pkt[dst_ip] = dst_pkt[dst_ip] + 1
        else:
            dst_pkt[dst_ip] = 1

def calculate_packets_counts_per_ips_proto(average_per_proto_src,protocol_name, src_ip,average_per_proto_dst, dst_ip):
    """
    Calculates the count of packets per protocol and src_ip (Also for per protocol and dst_ip)
    :param average_per_proto_src:
    :param protocol_name:
    :param src_ip:
    :param average_per_proto_dst:
    :param dst_ip:
    :return:
    """
    if average_per_proto_src.get(str((protocol_name, src_ip))):
        average_per_proto_src[str((protocol_name, src_ip))] = average_per_proto_src[str((protocol_name, src_ip))] + 1
    else:
        average_per_proto_src[str((protocol_name, src_ip))] = 1

    if average_per_proto_dst.get(str((protocol_name, dst_ip))):
        average_per_proto_dst[str((protocol_name, dst_ip))] = average_per_proto_dst[str((protocol_name, dst_ip))] + 1
    else:
        average_per_proto_dst[str((protocol_name, dst_ip))] = 1

def calculate_packets_count_per_ports_proto(average_per_proto_src_port,average_per_proto_dst_port,protocol_name,src_port,dst_port):
    """
    calculates the count of packets per protocol and src_port (Also, per protocol and dst_port)
    :param average_per_proto_src_port:
    :param average_per_proto_dst_port:
    :param protocol_name:
    :param src_port:
    :param dst_port:
    :return:
    """
    if average_per_proto_src_port.get(str((protocol_name, src_port))):
        average_per_proto_src_port[str((protocol_name, src_port))] = average_per_proto_src_port[
                                                                         str((protocol_name, src_port))] + 1
    else:
        average_per_proto_src_port[str((protocol_name, src_port))] = 1

    if average_per_proto_dst_port.get(str((protocol_name, dst_port))):
        average_per_proto_dst_port[str((protocol_name, dst_port))] = average_per_proto_dst_port[
            str((protocol_name, dst_port))]

    else:
        average_per_proto_dst_port[str((protocol_name, dst_port))] = 1


--- File: csv_files ---

--- File: output ---

--- File: split_temp ---

